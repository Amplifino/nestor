package com.amplifino.nestor.jdbc.wrappers;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashSet;
import java.util.Set;

public class ConnectionHandle extends ConnectionWrapper {
	
	private final Set<Statement> statements = new HashSet<>();
	
	public ConnectionHandle(Connection connection) {
		super(connection);
	}
	
	public ConnectionHandle(Connection connection, SqlConsumer<Connection> onClose) {
		super(connection, onClose);
	}
	
	@Override
	public Statement createStatement() throws SQLException {
		return track(super.createStatement());
	}
	
	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
		return track(super.createStatement(resultSetType, resultSetConcurrency));
	}
	
	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		return track(super.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability));
	}
	
	private Statement track(Statement statement) {
		statements.add(statement);
		return new StatementWrapper(statement, this::close);
	}
	
	@Override
	public CallableStatement prepareCall(String sql) throws SQLException {
		return trackCallable(super.prepareCall(sql));
	};
	
	@Override
	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		return trackCallable(super.prepareCall(sql,resultSetType, resultSetConcurrency));
	};
	
	@Override
	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		return trackCallable(super.prepareCall(sql, resultSetType, resultSetConcurrency , resultSetHoldability));
	};
	
	private CallableStatement trackCallable(CallableStatement statement) throws SQLException {
		statements.add(statement);
		return new CallableStatementWrapper(statement, this::close);
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		return trackPrepared(super.prepareStatement(sql));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
		return trackPrepared(super.prepareStatement(sql, autoGeneratedKeys));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
		return trackPrepared(super.prepareStatement(sql, columnIndexes));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
		return trackPrepared(super.prepareStatement(sql, columnNames));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		return trackPrepared(super.prepareStatement(sql, resultSetType, resultSetConcurrency));
	}
	
	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		return trackPrepared(super.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability));
	}
	
	private PreparedStatement trackPrepared(PreparedStatement statement) {
		statements.add(statement);
		return new PreparedStatementWrapper(statement, this::close);
	}
	
	@Override
	public void close() throws SQLException {
		for (Statement statement : statements) {
			try {
				statement.close();
			} catch (SQLException e) {
			}
		}
		super.close();
	}
	
	private void close(Statement statement) throws SQLException {
		statements.remove(statement);
		statement.close();
	}
	
	

}
